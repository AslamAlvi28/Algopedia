// Author: Rahul Mishra
// Email: rahul.mishra2003@gmail.com



*****************************************************************************************************
//Prime Number algorithms

//method 1
/*compelexity o(N)
*/
void checkprime(lld N){
    lld count = 0;
    for( lld i = 1;i <= N;++i )
        if( N % i == 0 )
            count++;
    if(count == 2)
        cout << N << “ is a prime number.” << endl;
    else
        cout << N << “ is not a prime number.” << endl;
}

//Method 2
// Complexity O(sqrt(N))
//can be used to calculate number of divisors 
void checkprime(lld N) {
    lld count = 0;
    for( lld i = 1;i * i <=N;++i ) {
         if( N % i == 0) {
         if( i * i == N )
                     count++;
                 else                                                     // i < sqrt(N) and (N / i) > sqrt(N)
                     count += 2;
      }
    }
    if(count == 2)
        cout << N << “ is a prime number.” << endl;
    else
        cout << N << “ is not a prime number.” << endl;
}


//Method 3
// Complexity O(sqrt(N)/2) ~= O(sqrt(n))
//i.e. check for only odd numbers till sqrt(n)
//can be used to calculate number of divisors 
void checkprime(lld N) {
    lld count = 0;
    for( lld i = 3;i * i <=N;i+=2 ) {
         if( N % i == 0) {
         if( i * i == N )
                     count++;
                 else                                                     // i < sqrt(N) and (N / i) > sqrt(N)
                     count += 2;
      }
    }
    if(count == 2)
        cout << N << “ is a prime number.” << endl;
    else
        cout << N << “ is not a prime number.” << endl;
}



//Method 4

//Sieve of Eratosthenes   O(nlog(logn))
#define FOR(i,s,e,in) for(int i=s;i<=e;i+=in)
typedef long long int lld;
vector<lld> prime;
bool check[1000000]={0};
void sieve()
{
    FOR(i,2,1000000,1)
    {
        if(check[i]==0)
        {
            prime.push_back(i);
            FOR(j,i,1000000,i)
            {
                check[j]=1;
            }
        }
    }   
}


//method 5
//using primes generated by seive of eratosthenes to 
//find prime numbers
// O(sqrt(n)/sqrt(log(n)))
void checkprime(lld N) {
    lld count = 0;
    for( lld i = 0;i<=(int)prime.size();++i ) 
    {
         if( N % prime[i] == 0) 
                     count++;
         if(count>=2)
         			break;		
    }
    if(count == 2)
        cout << N << “ is not a prime number.” << endl;
    else
        cout << N << “ is a prime number.” << endl;


//method 6
/* prime factorisation of a number
using the prime numbers being generated by seive of eratosthenes
storing factors and their respective powers


further this can be used to find the following

1. count the number of prime factors
2. count the different prime factors
3. sum of prime factors of n.

*/
vector <lld> factors;
vector <lld> power;
void factorisation(lld N)
{

    lld i=0;
    sieve();
	while(prime[i]*prime[i]<=N)
	{
		lld c=0;
		while(N%prime[i]==0)
		{
			N/=prime[i];
			++c;
			if(N%prime[i]!=0)
            {
                   factors.push_back(prime[i]);
                   power.push_back(c);

            }


		}

	  ++i;
	}
	if(N!=1)
	{
    factors.push_back(N);
    power.push_back(1);
	}

}

//Method 7
/* Finding number of prime factors for a range of number

*/
vector<ld>diffPrime(N,0);
vector<ld> countDiffPrime(ld N)
{
	FOR (i,2,N,1)
	{
		if(diffPrime[i]==0)
		{
			FOR(j,i,N,i)
			{
				diffPrime[j]++;
			}
		}
	}
}






















//method 8

/*
1. calculating the number of divisors of a number
*/
ulld NumberOfDivisors(ulld N)
{

    ulld i=0;
    ulld ans=1;
    sieve();
	while(prime[i]*prime[i]<=N)
	{

		lld power=0;
		while(N%prime[i]==0)
		{
			N/=prime[i];
			++power;
		}
		ans=ans*(power+1);		
	  ++i;
	}
	if(N!=1)
	{
	  ans=ans*2;

    }

return ans;
}



//method 9
//1. calculating the sum of divisors of a number
ulld SumOfDivisors(ulld N)
{

    ulld i=0;
    ulld Sum=1;
    sieve();
	while(prime[i]*prime[i]<=N)
	{

		ulld power=0;
		while(N%prime[i]==0)
		{
			N/=prime[i];
			++power;
		}
		ulld temp=pow(prime[i],power+1);
		Sum=(Sum*(temp-1))/(prime[i]-1);

	  ++i;
	}
	if(N!=1)
	{
	  Sum=(Sum*((N*N)-1))/(N-1);

    }
return Sum;
}


//method 10
//Euler phi(N) or Euler totient func(N)
//It means number of numbers that are < N and co-prime to it ,.i.e. gcd(N,i)=1
lld EulerPhi(lld N)
{

    lld i=0;
    lld EulerPhiNumber=N;
    sieve();
	while(prime[i]*prime[i]<=N)
	{

		lld factor=prime[i];
		bool div=false;
		while(N%prime[i]==0)
		{
			N/=prime[i];
			div=true;
		}
        if(div)
		EulerPhiNumber=(EulerPhiNumber/factor)*(factor-1);

	  ++i;
	}
	if(N!=1)
	{
	    EulerPhiNumber=(EulerPhiNumber/N)*(N-1);

    }
return EulerPhiNumber;
}

//method 10 A
// Euler phi for a range of number upto N
vector<ld> EulerPhiRange(ld N)
{
    vector<ld>EulerPhi(N+1,0);
    FOR(i,0,N,1)
    {
        EulerPhi[i]=i;
    }
    sieve();
    for(int i=0; prime[i]<=N; i++)
    {
        FOR(j,prime[i],N,prime[i])
        {
            EulerPhi[j]-=(EulerPhi[j]/prime[i]);
        }
    }

    return EulerPhi;
}